<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LEVEL 50: MOBILE OPTIMIZED</title>
    <style>
        /* Junni é¢¨æ ¼ï¼šæ¥µç°¡é»‘ç™½ */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; 
            user-select: none; -webkit-user-select: none; letter-spacing: 1px;
        }
        
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease-out;
        }
        #loading-text { color: #fff; font-size: 14px; margin-bottom: 30px; text-transform: uppercase; opacity: 0.7; }
        #start-btn {
            padding: 12px 40px; font-size: 14px; background: transparent; 
            color: #fff; border: 1px solid #fff; cursor: pointer; 
            transition: all 0.3s ease; display: none; text-transform: uppercase; letter-spacing: 2px;
        }
        #start-btn:hover { background: #fff; color: #000; }

        /* --- æ‰‹æ©Ÿå°ˆå±¬æŒ‰éˆ• (Mobile UI) --- */
        .mobile-btn {
            position: absolute; z-index: 1200; 
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.5);
            color: white; padding: 15px 25px; border-radius: 30px;
            font-size: 14px; font-weight: bold; pointer-events: auto;
            display: none; /* é è¨­éš±è—ï¼Œæœ‰äº’å‹•æ‰é¡¯ç¤º */
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            touch-action: manipulation;
        }
        .mobile-btn:active { background: rgba(255, 255, 255, 0.8); color: black; }

        /* äº’å‹•æŒ‰éˆ• (å³ä¸‹) */
        #btn-interact { bottom: 80px; right: 30px; border-color: cyan; color: cyan; }
        /* é›¢é–‹/ç«™èµ·æŒ‰éˆ• (ä¸­ä¸‹) */
        #btn-exit { bottom: 80px; left: 50%; transform: translateX(-50%); border-color: #ff5555; color: #ff5555; }

        /* æª¢è¦–æ¨¡å¼ UI */
        #inspect-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: transparent; 
            z-index: 1500; display: none; pointer-events: none; 
        }
        #inspect-info {
            position: absolute; right: 8%; top: 50%; transform: translateY(-50%);
            width: 300px; text-align: left; color: white; pointer-events: auto;
        }
        #inspect-title {
            font-size: 32px; font-weight: 300; color: #fff; margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 15px;
            text-transform: uppercase; letter-spacing: 3px;
        }
        #inspect-desc { 
            font-size: 14px; line-height: 2.0; color: rgba(255,255,255,0.8); margin-bottom: 30px; 
            font-weight: 300;
        }
        #inspect-hint {
            font-size: 12px; color: rgba(255,255,255,0.5); 
            border: 1px solid rgba(255,255,255,0.3); padding: 8px 15px; 
            display: inline-block; text-transform: uppercase;
        }

        #screen-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 70%; height: 60%; z-index: 800; display: none;
            background: #000; border: 1px solid #333;
        }
        #game-frame { width: 100%; height: 100%; border: none; }
        
        /* PC ç‰ˆæç¤º */
        #exit-hint {
            position: absolute; bottom: 8%; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.8); font-size: 12px; letter-spacing: 1px;
            display: none; pointer-events: none; z-index: 900;
            text-transform: uppercase;
        }

        #music-btn {
            position: absolute; top: 30px; right: 30px; z-index: 900;
            background: transparent; border: 1px solid rgba(255,255,255,0.3); 
            color: rgba(255,255,255,0.8);
            padding: 8px 20px; border-radius: 50px; cursor: pointer;
            font-size: 12px; transition: 0.3s; letter-spacing: 1px;
        }
        #music-btn:hover { border-color: #fff; color: #fff; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 8px; height: 8px; 
            border: 1px solid rgba(255,255,255,0.8);
            border-radius: 50%; transform: translate(-50%, -50%);
            z-index: 50; pointer-events: none;
            transition: 0.3s ease;
        }
        
        #interact-hint {
            position: absolute; top: 54%; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.9); font-size: 12px; pointer-events: none;
            display: none; letter-spacing: 1px; font-weight: 300;
        }

        /* åä¸‹æç¤º (PC) */
        #sit-hint {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 14px; display: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px; 
            letter-spacing: 2px; font-weight: 300;
        }

        #ui-layer { position: absolute; top: 30px; left: 30px; pointer-events: none; color: white; }
        .brand { font-size: 16px; font-weight: 400; letter-spacing: 2px; margin-bottom: 8px; }
        .instruction { font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 4px; }
        
        /* æ–æ¡¿ä½ç½® */
        #joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; z-index: 10; }
        /* è¦–è§’è§¸æ§å€ (å³åŠé‚Š) */
        #touch-look-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; z-index: 9; }

        #error-msg {
            position: absolute; bottom: 10px; left: 10px; color: #ff5555; background: rgba(0,0,0,0.8);
            padding: 10px; display: none; max-width: 90%; z-index: 1000; border-left: 2px solid red;
        }
        
        /* æ‰‹æ©Ÿç‰ˆæ’ç‰ˆèª¿æ•´ */
        @media (max-width: 768px) { 
            #joystick-zone { bottom: 30px; left: 20px; width: 120px; height: 120px; } 
            #inspect-info { width: 80%; right: auto; left: 10%; top: 60%; }
            #inspect-title { font-size: 24px; }
            #ui-layer { display: none; } /* æ‰‹æ©Ÿéš±è—å·¦ä¸Šèªªæ˜ï¼Œå¤ªæ“  */
        }
    </style>
</head>
<body>

    <audio id="bgm" loop><source src="music.mp3" type="audio/mpeg"></audio>

    <div id="loading-screen">
        <div id="loading-text">LOADING EXPERIENCE...</div>
        <button id="start-btn">ENTER</button>
    </div>

    <div id="screen-overlay">
        <iframe id="game-frame" src="" allow="autoplay; encrypted-media" allowfullscreen></iframe>
    </div>

    <!-- æª¢è¦– UI -->
    <div id="inspect-overlay">
        <div id="inspect-info">
            <div id="inspect-title">Title</div>
            <div id="inspect-desc">Description content here.</div>
            <!-- æ‰‹æ©Ÿç‰ˆä¸éœ€è¦é€™å€‹æç¤ºï¼Œå› ç‚ºæœ‰æŒ‰éˆ• -->
            <div id="inspect-hint" class="desktop-only">SPACE to close</div>
        </div>
    </div>

    <!-- æ‰‹æ©Ÿå°ˆå±¬æŒ‰éˆ• -->
    <div id="btn-interact" class="mobile-btn">ğŸ‘‹ INTERACT</div>
    <div id="btn-exit" class="mobile-btn">âŒ EXIT</div>

    <div id="music-btn">MUSIC ON</div>
    <div id="error-msg"></div>
    
    <div id="crosshair"></div>
    <div id="interact-hint"></div> <!-- PC æç¤º -->
    <div id="exit-hint">PRESS [SPACE] TO LEAVE</div> <!-- PC æç¤º -->
    <div id="sit-hint">PRESS [SPACE] TO STAND UP</div> <!-- PC æç¤º -->

    <div id="ui-layer">
        <div class="brand">PORTFOLIO</div>
        <div class="instruction">PC: WASD / Space</div>
    </div>

    <div id="joystick-zone"></div>
    <div id="touch-look-zone"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==========================================
        // ğŸ”¥ è¨­å®šå€
        // ==========================================
        
        const INTERACT_CONFIG = {
            "coffee_cup": { 
                type: "inspect", 
                title: "Coffee Break", 
                desc: "A moment of peace.",
                inspectRotation: { x: 0.5, y: 0, z: 0 } 
            },
            "sofa": { type: "sit", rotation: 270 }, 
            "chair": { type: "sit", rotation: 180 }, 
            "TV": { type: "tv", src: "https://www.youtube.com/embed/jfKfPfyJRdk?autoplay=1&mute=0" },
            "window": { type: "view" }
        };

        const ROOM_SCALE = 1.0; 
        const moveSpeed = 4.0;     
        const sprintSpeed = 8.0;
        const baseHeight = 1.7;
        const sitHeight = 0.8;      

        // ==========================================

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerText = msg;
        }

        let scene, camera, renderer, composer, clock;
        let sceneStudio, cameraStudio;
        let studioObject = null;
        let studioPivot = null; 
        
        let player; 
        let isGameActive = false;
        
        let collisionObjects = []; 
        const raycaster = new THREE.Raycaster();
        const keysPressed = {};

        const mouseSensitivity = 0.002; 
        const bobFrequency = 8; 
        const bobAmplitude = 0.10;   

        let controlState = "move"; 
        let currentCamHeight = baseHeight;
        
        // äº’å‹•ç›®æ¨™
        let hoverConfig = null;
        let hoverRoot = null;
        let hoverPoint = null;

        let cameraPitch = 0; 
        let cameraYaw = 0;   
        let direction = new THREE.Vector3();
        let touchLastX = 0;
        let touchLastY = 0;

        let isMusicPlaying = false;
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-btn');

        // --- æŒ‰éˆ•åƒè€ƒ ---
        const btnInteract = document.getElementById('btn-interact');
        const btnExit = document.getElementById('btn-exit');

        musicBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleMusic();
        });

        function toggleMusic() {
            if (isMusicPlaying) {
                bgm.pause();
                isMusicPlaying = false;
                musicBtn.innerText = "MUSIC OFF";
                musicBtn.style.opacity = "0.5";
            } else {
                bgm.play().catch(e => console.log("No music"));
                isMusicPlaying = true;
                musicBtn.innerText = "MUSIC ON";
                musicBtn.style.opacity = "1.0";
            }
        }

        function exitInteraction() {
            document.getElementById('screen-overlay').style.display = 'none';
            document.getElementById('game-frame').src = "";
            document.getElementById('inspect-overlay').style.display = 'none';
            
            if (studioObject) {
                sceneStudio.remove(studioPivot); 
                studioObject = null;
                studioPivot = null;
            }

            document.getElementById('exit-hint').style.display = 'none';
            document.getElementById('sit-hint').style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
            
            // æ‰‹æ©ŸæŒ‰éˆ•è™•ç†
            btnExit.style.display = 'none'; // éš±è—é›¢é–‹æŒ‰éˆ•

            if(controlState === "watch" && musicBtn.innerText.includes("ON")) {
                bgm.play().catch(()=>{});
            }

            controlState = "move";
            currentCamHeight = baseHeight; 

            lockPointer();
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            const screen = document.getElementById('loading-screen');
            screen.style.opacity = 0;
            setTimeout(() => { screen.style.display = 'none'; isGameActive = true; }, 800);
            
            bgm.volume = 0.5;
            bgm.play().then(() => { isMusicPlaying = true; }).catch(() => {});
            lockPointer();
        });

        // --- æ‰‹æ©Ÿäº’å‹•æŒ‰éˆ•ç›£è½ ---
        btnInteract.addEventListener('touchstart', (e) => {
            e.preventDefault(); // é˜²æ­¢è§¸ç™¼é»æ“Šç©¿é€
            if (controlState === "move" && hoverConfig && hoverRoot) {
                handleInteraction(hoverRoot, hoverConfig);
            }
        });

        btnExit.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (controlState !== "move") exitInteraction();
        });

        // --- PC æ»‘é¼ é»æ“Š (åªè² è²¬é–å®š + äº’å‹•) ---
        document.body.addEventListener('mousedown', (e) => {
            if (!isGameActive || e.target.id === 'music-btn' || e.target.classList.contains('mobile-btn')) return;

            if (e.button === 0) {
                if (document.pointerLockElement !== document.body && controlState === "move") {
                    lockPointer();
                    return;
                }
                
                if (controlState === "move" && hoverConfig && hoverRoot) {
                    handleInteraction(hoverRoot, hoverConfig);
                }
            }
        });

        document.addEventListener('contextmenu', event => event.preventDefault());

        function lockPointer() {
            // æ‰‹æ©Ÿä¸éœ€è¦ pointerLockï¼Œåªåœ¨ PC åŸ·è¡Œ
            if (!('ontouchstart' in window)) {
                document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
                document.body.requestPointerLock();
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505); 
            scene.fog = new THREE.FogExp2(0x050505, 0.01);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100); 
            camera.rotation.order = 'YXZ'; 

            // æ”å½±æ£š
            sceneStudio = new THREE.Scene();
            const bgGeo = new THREE.PlaneGeometry(20, 20);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8, depthTest: false });
            const studioBg = new THREE.Mesh(bgGeo, bgMat);
            studioBg.position.set(0, 0, -10); 
            studioBg.renderOrder = -1; 
            
            cameraStudio = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            cameraStudio.position.set(0, 0, 2);
            sceneStudio.add(cameraStudio);
            cameraStudio.add(studioBg);

            const studioAmbient = new THREE.AmbientLight(0xffffff, 1.2);
            sceneStudio.add(studioAmbient);
            const studioDir = new THREE.DirectionalLight(0xffffff, 1.5);
            studioDir.position.set(2, 2, 5);
            sceneStudio.add(studioDir);
            const studioBack = new THREE.DirectionalLight(0xffffff, 0.8);
            studioBack.position.set(-2, 0, -5); 
            sceneStudio.add(studioBack);

            // --- [æ•ˆèƒ½å„ªåŒ–é—œéµ] ---
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // é—œé–‰åŸç”ŸæŠ—é‹¸é½’ (å› ç‚ºç”¨äº† Composer)
                powerPreference: "high-performance" // è«‹æ±‚é«˜æ€§èƒ½
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // [é—œéµ] é™åˆ¶ PixelRatioï¼Œé¿å…æ‰‹æ©Ÿè·‘ 3x è§£æåº¦å°è‡´å¡é “
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
            
            renderer.useLegacyLights = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 0.9; 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.9; 
            bloomPass.strength = 0.2; 
            bloomPass.radius = 0.1;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222222, 0.6);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const playerLight = new THREE.SpotLight(0xffffff, 0.8);
            playerLight.position.set(0, 0, 0);
            playerLight.target.position.set(0, 0, -5);
            playerLight.angle = Math.PI / 5;
            playerLight.penumbra = 0.5;
            playerLight.distance = 15; 
            camera.add(playerLight);
            camera.add(playerLight.target);
            scene.add(camera);

            const loader = new GLTFLoader();
            // Draco è§£ç¢¼
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);

            const loadingText = document.getElementById('loading-text');
            const startBtn = document.getElementById('start-btn');

            loader.load('./room.glb', function(gltf) {
                const room = gltf.scene;
                room.scale.set(ROOM_SCALE, ROOM_SCALE, ROOM_SCALE); 
                room.position.set(0, 0, 0);
                
                room.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        collisionObjects.push(child); 
                        if(child.material) {
                            child.material.side = THREE.DoubleSide;
                            if(child.material.isMeshStandardMaterial) {
                                child.material.roughness = 0.8; 
                                child.material.metalness = 0.1;
                            }
                        }
                    }
                });
                scene.add(room);
                loadingText.innerText = "READY";
                startBtn.style.display = "block";
            }, undefined, function(err) {
                showError("Failed to load room.glb.");
                console.error(err);
            });

            const pGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6); 
            const pMat = new THREE.MeshBasicMaterial({ visible: false, wireframe: true }); 
            player = new THREE.Mesh(pGeo, pMat);
            player.position.set(0, 2, 0); 
            scene.add(player);

            clock = new THREE.Clock();
            document.addEventListener('mousemove', onMouseMove);
            
            const touchZone = document.getElementById('touch-look-zone');
            touchZone.addEventListener('touchstart', (e) => {
                touchLastX = e.touches[0].clientX;
                touchLastY = e.touches[0].clientY;
            });
            touchZone.addEventListener('touchmove', (e) => {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - touchLastX;
                const deltaY = touchY - touchLastY;
                rotateCamera(deltaX * 2, deltaY * 2);
                touchLastX = touchX;
                touchLastY = touchY;
            });

            animate();
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === document.body && controlState === "move") {
                rotateCamera(event.movementX, event.movementY);
            }
        }

        function rotateCamera(moveX, moveY) {
            cameraYaw -= moveX * mouseSensitivity;
            cameraPitch -= moveY * mouseSensitivity;
            cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraPitch));
            camera.rotation.x = cameraPitch;
            camera.rotation.y = cameraYaw;
        }

        function checkCollision(nextPos) {
            const rayOrigin = nextPos.clone();
            rayOrigin.y += 0.3; 
            const dir = nextPos.clone().sub(player.position).normalize();
            raycaster.set(rayOrigin, dir);
            const intersects = raycaster.intersectObjects(collisionObjects, true);
            if (intersects.length > 0 && intersects[0].distance < 0.6) {
                return true; 
            }
            return false;
        }

        function handleInteraction(object, config) {
            // éš±è—æ‰‹æ©Ÿäº’å‹•æŒ‰éˆ•ï¼Œé¡¯ç¤ºé›¢é–‹æŒ‰éˆ•
            btnInteract.style.display = 'none';
            btnExit.style.display = 'block';

            if (config.type === "sit") {
                controlState = "sit";
                const intersectPoint = raycaster.intersectObject(object, true)[0].point;
                player.position.x = intersectPoint.x;
                player.position.z = intersectPoint.z;
                cameraYaw = (config.rotation * Math.PI) / 180;
                cameraPitch = 0; 
                
                // PC æç¤º
                document.getElementById('exit-hint').style.display = 'block';
                document.getElementById('exit-hint').innerText = "PRESS [SPACE] TO STAND UP";
                
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('interact-hint').style.display = 'none';
            }
            else if (config.type === "tv" || config.type === "view") {
                controlState = "watch";
                if (document.pointerLockElement) document.exitPointerLock();
                
                const targetPos = new THREE.Vector3();
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                camera.lookAt(center);
                
                if (config.type === "tv") {
                    const screen = document.getElementById('screen-overlay');
                    const iframe = document.getElementById('game-frame');
                    iframe.src = config.src;
                    screen.style.display = 'block';
                    if (isMusicPlaying) bgm.pause(); 
                }
                document.getElementById('exit-hint').style.display = 'block';
                document.getElementById('exit-hint').innerText = "PRESS [SPACE] TO EXIT";
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('interact-hint').style.display = 'none';
            }
            
            else if (config.type === "inspect") {
                controlState = "inspect";
                
                studioObject = object.clone();
                studioObject.scale.set(1, 1, 1);
                studioObject.rotation.set(0, 0, 0);

                if (config.inspectRotation) {
                    studioObject.rotation.x = config.inspectRotation.x || 0;
                    studioObject.rotation.y = config.inspectRotation.y || 0;
                    studioObject.rotation.z = config.inspectRotation.z || 0;
                }

                studioObject.traverse((child) => {
                    if(child.isMesh) {
                        child.material.side = THREE.DoubleSide;
                        if(child.material.isMeshStandardMaterial) {
                            child.material.metalness = 0.0; 
                            child.material.roughness = 0.5;
                            child.material.emissive = new THREE.Color(0x222222);
                        }
                    }
                });

                studioObject.updateMatrixWorld(true);

                const box = new THREE.Box3().setFromObject(studioObject);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                studioObject.position.x = -center.x;
                studioObject.position.y = -center.y;
                studioObject.position.z = -center.z;
                
                studioPivot = new THREE.Group();
                studioPivot.add(studioObject);
                sceneStudio.add(studioPivot);

                const maxDim = Math.max(size.x, size.y, size.z);
                cameraStudio.position.z = Math.max(maxDim * 2.0, 1.0); 
                cameraStudio.lookAt(0, 0, 0);

                document.getElementById('inspect-title').innerText = config.title;
                document.getElementById('inspect-desc').innerText = config.desc;
                document.getElementById('inspect-overlay').style.display = 'block';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('interact-hint').style.display = 'none';
            }
        }

        function findConfigInHierarchy(mesh) {
            let current = mesh;
            while (current) {
                for (const key in INTERACT_CONFIG) {
                    if (current.name.toLowerCase().includes(key.toLowerCase())) {
                        return { config: INTERACT_CONFIG[key], root: current };
                    }
                }
                if (current.parent === scene) break; 
                current = current.parent;
            }
            return null;
        }

        function checkInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(collisionObjects, true);
            const crosshair = document.getElementById('crosshair');
            const hint = document.getElementById('interact-hint');

            if (intersects.length > 0) {
                const dist = intersects[0].distance;
                if (dist < 3.0) {
                    const result = findConfigInHierarchy(intersects[0].object);
                    
                    if (result) {
                        hoverConfig = result.config;
                        hoverRoot = result.root;   
                        hoverPoint = intersects[0].point;

                        crosshair.style.backgroundColor = "lime";
                        crosshair.style.width = "10px";
                        crosshair.style.height = "10px";
                        hint.style.display = "block";
                        hint.style.color = (hoverConfig.type === "inspect") ? "#ff00ff" : "cyan";
                        
                        let actionText = "INTERACT";
                        if(hoverConfig.type === "sit") actionText = "SIT";
                        else if(hoverConfig.type === "tv") actionText = "WATCH";
                        else if(hoverConfig.type === "inspect") actionText = "INSPECT";
                        
                        hint.innerText = `[L-CLICK] ${actionText}`;

                        // æ‰‹æ©Ÿé¡¯ç¤ºæŒ‰éˆ•
                        btnInteract.style.display = "block";
                        btnInteract.innerText = "ğŸ‘‹ " + actionText;

                    } else {
                        hoverConfig = null;
                        resetCrosshair();
                    }
                } else {
                    hoverConfig = null;
                    resetCrosshair();
                }
            } else {
                hoverConfig = null;
                resetCrosshair();
            }
        }

        function resetCrosshair() {
            const crosshair = document.getElementById('crosshair');
            const hint = document.getElementById('interact-hint');
            crosshair.style.backgroundColor = "transparent";
            crosshair.style.width = "8px";
            crosshair.style.height = "8px";
            crosshair.style.border = "1px solid rgba(255,255,255,0.8)";
            hint.style.display = "none";
            btnInteract.style.display = "none"; // æ‰‹æ©Ÿéš±è—
        }

        window.addEventListener('keydown', (e) => {
            keysPressed[e.code] = true;
            if (e.code === 'Space') {
                if (controlState !== "move") exitInteraction();
            }
        });
        window.addEventListener('keyup', (e) => keysPressed[e.code] = false);
        
        const joystickManager = nipplejs.create({
            zone: document.getElementById('joystick-zone'),
            mode: 'static', position: { left: '50%', top: '50%' }, color: 'white'
        });
        let joystickVector = { x: 0, y: 0 };
        joystickManager.on('move', (evt, data) => {
            if (data.vector) { joystickVector.x = data.vector.x; joystickVector.y = data.vector.y; }
        });
        joystickManager.on('end', () => { joystickVector.x = 0; joystickVector.y = 0; });

        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;

            const dt = clock.getDelta();

            renderer.clear();
            composer.render();

            if (controlState === "inspect" && studioPivot) {
                studioPivot.rotation.y += 0.5 * dt; 
                renderer.clearDepth(); 
                renderer.render(sceneStudio, cameraStudio);
            }

            if (controlState === "move") {
                checkInteraction();

                let moveForward = 0;
                let moveRight = 0;

                if (keysPressed['KeyW'] || keysPressed['ArrowUp']) moveForward = 1;
                if (keysPressed['KeyS'] || keysPressed['ArrowDown']) moveForward = -1;
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) moveRight = -1;
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) moveRight = 1;

                if (joystickVector.y !== 0) moveForward = joystickVector.y;
                if (joystickVector.x !== 0) moveRight = joystickVector.x;

                const currentSpeed = keysPressed['ShiftLeft'] ? sprintSpeed : moveSpeed;

                direction.set(0, 0, 0);
                const forwardVec = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
                const rightVec = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

                if (moveForward !== 0) direction.add(forwardVec.multiplyScalar(moveForward));
                if (moveRight !== 0) direction.add(rightVec.multiplyScalar(moveRight));

                direction.normalize(); 

                let isMoving = (moveForward !== 0 || moveRight !== 0);

                if (isMoving) {
                    const moveDist = currentSpeed * dt;
                    const nextPos = player.position.clone().add(direction.clone().multiplyScalar(moveDist));
                    if (!checkCollision(nextPos)) {
                        player.position.copy(nextPos);
                    }
                }

                let bobOffset = 0;
                if (isMoving) {
                    const bobFreq = keysPressed['ShiftLeft'] ? 15 : bobFrequency; 
                    const bobAmp = keysPressed['ShiftLeft'] ? 0.2 : bobAmplitude; 
                    bobOffset = Math.sin(clock.elapsedTime * bobFreq) * bobAmp;
                } else {
                    bobOffset = THREE.MathUtils.lerp(0, 0, 0.1);
                }

                const targetCamY = player.position.y + baseHeight + bobOffset;
                currentCamHeight = THREE.MathUtils.lerp(currentCamHeight, targetCamY, 0.1);

                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
                camera.position.y = currentCamHeight;
                
                camera.rotation.x = cameraPitch;
                camera.rotation.y = cameraYaw;
            } 
            else if (controlState === "sit") {
                const targetCamY = player.position.y + sitHeight;
                currentCamHeight = THREE.MathUtils.lerp(currentCamHeight, targetCamY, 0.05);
                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
                camera.position.y = currentCamHeight;
                camera.rotation.y = THREE.MathUtils.lerp(camera.rotation.y, cameraYaw, 0.1);
                camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, 0, 0.1);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            cameraStudio.aspect = window.innerWidth / window.innerHeight;
            cameraStudio.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LEVEL 52: CINEMATIC VIEW</title>
    <style>
        /* ÂÖ®Â±ÄË®≠ÂÆö */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 300; letter-spacing: 1px;
            user-select: none; -webkit-user-select: none;
        }

        /* --- [Êñ∞Â¢û] ÈõªÂΩ±ÊÑüÊöóËßíÊøæÈè° (ÊïàËÉΩÊ•µ‰Ω≥ÁöÑË¶ñË¶∫‰ΩúÂºä) --- */
        #cinematic-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 800; pointer-events: none; /* ËÆìÊªëÈº†Á©øÈÄè */
            /* ÊîæÂ∞ÑÁãÄÊº∏Â±§Ôºö‰∏≠ÈñìÈÄèÊòé -> ÂõõÂë®ËÆäÈªë */
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
            /* Â¶ÇÊûúÊÉ≥Ë¶ÅÂõõÂë®ÊúâÈªûÊ®°Á≥äÊÑüÔºåÂèØ‰ª•Âä†ÈÄôË°å (Êúâ‰∫õÊâãÊ©üÂèØËÉΩ‰∏çÊîØÊè¥) */
            /* backdrop-filter: blur(1px); */ 
        }
        
        /* Loading */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0a0a; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease-out;
        }
        #loading-text { 
            color: #fff; font-size: 12px; margin-bottom: 40px; 
            letter-spacing: 3px; text-transform: uppercase; opacity: 0.6;
        }
        #start-btn {
            padding: 15px 60px; font-size: 12px; background: transparent; 
            color: #fff; border: 1px solid rgba(255,255,255,0.3); cursor: pointer; 
            transition: all 0.4s ease; display: none; 
            text-transform: uppercase; letter-spacing: 2px;
        }
        #start-btn:hover { border-color: #fff; background: rgba(255,255,255,0.1); }

        /* Ê™¢Ë¶ñ UI */
        #inspect-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: transparent; 
            z-index: 1500; display: none; 
        }
        #inspect-info {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 600px; text-align: center; color: white; pointer-events: none;
        }
        #inspect-title {
            font-size: 24px; font-weight: 400; color: #fff; margin-bottom: 10px;
            letter-spacing: 3px; text-transform: uppercase;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        #inspect-desc { 
            font-size: 13px; line-height: 1.8; color: rgba(255,255,255,0.8); 
            font-weight: 300; max-width: 400px; margin: 0 auto;
            text-shadow: 0 1px 5px rgba(0,0,0,0.8);
        }
        #inspect-hint {
            margin-top: 20px; font-size: 10px; color: rgba(255,255,255,0.5); 
            text-transform: uppercase; letter-spacing: 1px;
        }

        /* ÈõªË¶ñÂÆπÂô® */
        #screen-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; height: 70%; z-index: 1600; display: none;
            background: #000; border: none;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        #game-frame { width: 100%; height: 100%; border: none; }
        
        /* Èü≥Ê®ÇÊåâÈàï */
        #music-btn {
            position: absolute; top: 30px; right: 30px; z-index: 1200;
            background: transparent; border: none; 
            color: rgba(255,255,255,0.4);
            cursor: pointer; font-size: 10px; letter-spacing: 2px;
            transition: 0.3s; text-transform: uppercase;
        }
        #music-btn:hover { color: #fff; }

        /* Ê∫ñÂøÉ */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: rgba(255,255,255,0.8);
            border-radius: 50%; transform: translate(-50%, -50%);
            z-index: 1100; pointer-events: none;
            transition: all 0.2s ease;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        
        /* ‰∫íÂãïÊèêÁ§∫ */
        #interact-label {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(15px, -50%);
            color: rgba(255,255,255,0.9); font-size: 10px; pointer-events: none;
            display: none; letter-spacing: 1px; font-weight: 400;
            text-transform: uppercase;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            z-index: 1100;
        }

        /* ÁãÄÊÖãÊèêÁ§∫ (Á´ôËµ∑/ÈÄÄÂá∫) */
        #status-hint {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); font-size: 11px; letter-spacing: 2px;
            display: none; pointer-events: none; z-index: 1100;
            text-transform: uppercase; 
        }

        /* ÂìÅÁâå */
        #brand-logo {
            position: absolute; top: 30px; left: 30px; 
            font-size: 12px; color: rgba(255,255,255,0.5); 
            letter-spacing: 3px; pointer-events: none; z-index: 1100;
        }

        /* ÊâãÊ©üÊåâÈàï */
        .mobile-btn {
            position: absolute; z-index: 1300; 
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; width: 50px; height: 50px; border-radius: 50%;
            font-size: 18px; display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            display: none; touch-action: manipulation;
        }
        .mobile-btn:active { background: rgba(255, 255, 255, 0.4); }

        #btn-interact { bottom: 60px; right: 30px; }
        #btn-crouch { bottom: 60px; left: 20px; font-size: 16px; }
        #btn-exit { top: 30px; left: 30px; width: 40px; height: 40px; font-size: 14px; }

        #joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; z-index: 1000; }
        #touch-look-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; z-index: 900; }

        #error-msg {
            position: absolute; bottom: 10px; left: 10px; color: #ff5555; background: rgba(0,0,0,0.8);
            padding: 10px; display: none; max-width: 90%; z-index: 2000; border-left: 2px solid red;
        }
        
        @media (max-width: 768px) { 
            #joystick-zone { bottom: 30px; left: 20px; width: 120px; height: 120px; } 
            #brand-logo, #music-btn { display: none; } 
            #btn-crouch { display: flex; }
        }
    </style>
</head>
<body>

    <!-- Èü≥Ê®Ç -->
    <audio id="bgm" loop><source src="music.mp3" type="audio/mpeg"></audio>

    <!-- ËºâÂÖ•Áï´Èù¢ -->
    <div id="loading-screen">
        <div id="loading-text">LOADING SPACE</div>
        <button id="start-btn">ENTER</button>
    </div>

    <!-- ÈõªÂΩ±ÊÑüÊøæÈè° (Vignette) -->
    <div id="cinematic-vignette"></div>

    <!-- ÈõªË¶ñÁï´Èù¢ -->
    <div id="screen-overlay">
        <iframe id="game-frame" src="" allow="autoplay; encrypted-media" allowfullscreen></iframe>
    </div>

    <!-- Ê™¢Ë¶ñË≥áË®ä -->
    <div id="inspect-overlay">
        <div id="inspect-info">
            <div id="inspect-title">Title</div>
            <div id="inspect-desc">Description content.</div>
            <div id="inspect-hint">DRAG TO ROTATE</div>
        </div>
    </div>

    <!-- UI ÂÖÉ‰ª∂ -->
    <div id="btn-interact" class="mobile-btn">‚óè</div>
    <div id="btn-crouch" class="mobile-btn">‚¨á</div>
    <div id="btn-exit" class="mobile-btn">‚úï</div>

    <div id="brand-logo">PORTFOLIO</div>
    <button id="music-btn">SOUND OFF</button>
    <div id="error-msg"></div>
    
    <div id="crosshair"></div>
    <div id="interact-label"></div>
    <div id="status-hint"></div>

    <div id="joystick-zone"></div>
    <div id="touch-look-zone"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==========================================
        // üî• Ë®≠ÂÆöÂçÄ
        // ==========================================
        
        const INTERACT_CONFIG = {
            "coffee_cup": { 
                type: "inspect", 
                title: "Coffee Break", 
                desc: "A cup of freshly brewed coffee.",
                inspectRotation: { x: 0.5, y: 0, z: 0 } 
            },
            "sofa": { type: "sit", rotation: 270 }, 
            "chair": { type: "sit", rotation: 180 }, 
            "TV": { type: "tv", src: "https://www.youtube.com/embed/jfKfPfyJRdk?autoplay=1&mute=0" },
            "window": { type: "view" }
        };

        const ROOM_SCALE = 1.0; 
        const moveSpeed = 4.0;     
        const sprintSpeed = 8.0;
        
        // --- [ÈóúÈçµ‰øÆÊ≠£] Ë∫´È´òË®≠ÂÆö ---
        const standHeight = 1.7; // Ê≠£Â∏∏‰∫∫ÁúºÈ´òÂ∫¶
        const crouchHeight = 1.0; 
        const sitHeight = 0.8;    

        // ==========================================

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerText = msg;
        }

        let scene, camera, renderer, composer, clock;
        let sceneStudio, cameraStudio;
        let studioObject = null;
        let studioPivot = null; 
        
        let player; 
        let isGameActive = false;
        
        let collisionObjects = []; 
        const raycaster = new THREE.Raycaster();
        const keysPressed = {};

        const mouseSensitivity = 0.002; 
        const bobFrequency = 8; 
        const bobAmplitude = 0.10;   

        let controlState = "move"; 
        let currentCamHeight = standHeight;
        let targetHeight = standHeight;
        let isCrouching = false;

        let hoverConfig = null;
        let hoverRoot = null;
        let hoverPoint = null;

        let cameraPitch = 0; 
        let cameraYaw = 0;   
        let direction = new THREE.Vector3();
        let touchLastX = 0;
        let touchLastY = 0;
        
        // Ê™¢Ë¶ñÊ®°ÂºèÊãñÊõ≥
        let isDragging = false;
        let dragLastX = 0;
        let dragLastY = 0;

        let isMusicPlaying = false;
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-btn');
        
        const btnInteract = document.getElementById('btn-interact');
        const btnCrouch = document.getElementById('btn-crouch');
        const btnExit = document.getElementById('btn-exit');
        const statusHint = document.getElementById('status-hint');

        musicBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleMusic();
        });

        function toggleMusic() {
            if (isMusicPlaying) {
                bgm.pause();
                isMusicPlaying = false;
                musicBtn.innerText = "SOUND OFF";
                musicBtn.style.opacity = "0.5";
            } else {
                bgm.play().catch(e => console.log("No music"));
                isMusicPlaying = true;
                musicBtn.innerText = "SOUND ON";
                musicBtn.style.opacity = "1.0";
            }
        }

        function exitInteraction() {
            document.getElementById('screen-overlay').style.display = 'none';
            document.getElementById('game-frame').src = "";
            document.getElementById('inspect-overlay').style.display = 'none';
            
            if (studioObject) {
                sceneStudio.remove(studioPivot); 
                studioObject = null;
                studioPivot = null;
            }

            statusHint.style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
            
            btnExit.style.display = 'none';
            if(window.innerWidth <= 768) btnCrouch.style.display = 'flex';

            if(controlState === "watch" && musicBtn.innerText.includes("ON")) {
                bgm.play().catch(()=>{});
            }

            controlState = "move";
            isCrouching = false;
            targetHeight = standHeight; 

            lockPointer();
        }

        function toggleCrouch() {
            if (controlState !== "move") return;
            isCrouching = !isCrouching;
            targetHeight = isCrouching ? crouchHeight : standHeight;
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            const screen = document.getElementById('loading-screen');
            screen.style.opacity = 0;
            setTimeout(() => { screen.style.display = 'none'; isGameActive = true; }, 800);
            
            bgm.volume = 0.5;
            bgm.play().then(() => { isMusicPlaying = true; musicBtn.innerText = "SOUND ON"; musicBtn.style.opacity = "1"; }).catch(() => {});
            lockPointer();
        });

        btnInteract.addEventListener('touchstart', (e) => {
            e.preventDefault(); e.stopPropagation();
            if (controlState === "move" && hoverConfig && hoverRoot) handleInteraction(hoverRoot, hoverConfig);
        });
        
        btnCrouch.addEventListener('touchstart', (e) => {
            e.preventDefault(); e.stopPropagation();
            toggleCrouch();
        });

        btnExit.addEventListener('touchstart', (e) => {
            e.preventDefault(); e.stopPropagation();
            if (controlState !== "move") exitInteraction();
        });

        document.body.addEventListener('mousedown', (e) => {
            if (!isGameActive || e.target.tagName === 'BUTTON' || e.target.classList.contains('mobile-btn')) return;

            if (e.button === 0) {
                if (controlState === "inspect") {
                    isDragging = true;
                    dragLastX = e.clientX;
                    dragLastY = e.clientY;
                    return;
                }

                if (document.pointerLockElement !== document.body && controlState === "move") {
                    lockPointer();
                    return;
                }
                
                if (controlState === "move" && hoverConfig && hoverRoot) {
                    handleInteraction(hoverRoot, hoverConfig);
                }
            }
        });

        document.body.addEventListener('mousemove', (e) => {
            if (controlState === "inspect" && isDragging && studioPivot) {
                const deltaX = e.clientX - dragLastX;
                const deltaY = e.clientY - dragLastY;
                studioPivot.rotation.y += deltaX * 0.01;
                studioPivot.rotation.x += deltaY * 0.01;
                dragLastX = e.clientX;
                dragLastY = e.clientY;
            }
            else if (document.pointerLockElement === document.body && controlState === "move") {
                rotateCamera(e.movementX, e.movementY);
            }
        });

        document.body.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('contextmenu', event => event.preventDefault());

        function lockPointer() {
            if (!('ontouchstart' in window)) {
                document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
                document.body.requestPointerLock();
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505); 
            scene.fog = new THREE.FogExp2(0x050505, 0.01);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100); 
            camera.rotation.order = 'YXZ'; 

            sceneStudio = new THREE.Scene();
            // Studio ‰∏çË®≠ËÉåÊôØÔºåÁî± CSS #cinematic-vignette ÂíåÂÖ®ÂüüÈªëËâ≤ËôïÁêÜ
            
            cameraStudio = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            cameraStudio.position.set(0, 0, 2);
            sceneStudio.add(cameraStudio);

            const lightKey = new THREE.DirectionalLight(0xffffff, 1.5);
            lightKey.position.set(2, 2, 5);
            sceneStudio.add(lightKey);
            const lightFill = new THREE.DirectionalLight(0xffffff, 0.8);
            lightFill.position.set(-2, 0, 5);
            sceneStudio.add(lightFill);
            const lightRim = new THREE.DirectionalLight(0xffffff, 1.0);
            lightRim.position.set(0, 5, -5);
            sceneStudio.add(lightRim);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.useLegacyLights = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 0.9; 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false; 
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.9; 
            bloomPass.strength = 0.2; 
            bloomPass.radius = 0.1;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222222, 0.6);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const playerLight = new THREE.SpotLight(0xffffff, 0.8);
            playerLight.position.set(0, 0, 0);
            playerLight.target.position.set(0, 0, -5);
            playerLight.angle = Math.PI / 5;
            playerLight.penumbra = 0.5;
            playerLight.distance = 15; 
            camera.add(playerLight);
            camera.add(playerLight.target);
            scene.add(camera);

            const loader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);

            const loadingText = document.getElementById('loading-text');
            const startBtn = document.getElementById('start-btn');

            loader.load('./room.glb', function(gltf) {
                const room = gltf.scene;
                room.scale.set(ROOM_SCALE, ROOM_SCALE, ROOM_SCALE); 
                room.position.set(0, 0, 0);
                
                room.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        collisionObjects.push(child); 
                        if(child.material) {
                            child.material.side = THREE.DoubleSide;
                            if(child.material.isMeshStandardMaterial) {
                                child.material.roughness = 0.8; 
                                child.material.metalness = 0.1;
                            }
                        }
                    }
                });
                scene.add(room);
                loadingText.innerText = "READY";
                startBtn.style.display = "block";
            }, undefined, function(err) {
                showError("Failed to load room.glb");
            });

            const pGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6); 
            const pMat = new THREE.MeshBasicMaterial({ visible: false, wireframe: true }); 
            player = new THREE.Mesh(pGeo, pMat);
            player.position.set(0, 2, 0); 
            scene.add(player);

            clock = new THREE.Clock();
            
            const joystickManager = nipplejs.create({
                zone: document.getElementById('joystick-zone'),
                mode: 'static', position: { left: '50%', top: '50%' }, color: 'white'
            });
            let joystickVector = { x: 0, y: 0 };
            joystickManager.on('move', (evt, data) => {
                if (data.vector) { joystickVector.x = data.vector.x; joystickVector.y = data.vector.y; }
            });
            joystickManager.on('end', () => { joystickVector.x = 0; joystickVector.y = 0; });

            const touchZone = document.getElementById('touch-look-zone');
            let touchLastX = 0;
            let touchLastY = 0;
            touchZone.addEventListener('touchstart', (e) => {
                touchLastX = e.touches[0].clientX;
                touchLastY = e.touches[0].clientY;
            });
            touchZone.addEventListener('touchmove', (e) => {
                if (controlState !== "move") return;
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - touchLastX;
                const deltaY = touchY - touchLastY;
                rotateCamera(deltaX * 2, deltaY * 2);
                touchLastX = touchX;
                touchLastY = touchY;
            });

            animate();
        }

        function rotateCamera(moveX, moveY) {
            cameraYaw -= moveX * mouseSensitivity;
            cameraPitch -= moveY * mouseSensitivity;
            cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraPitch));
            camera.rotation.x = cameraPitch;
            camera.rotation.y = cameraYaw;
        }

        function checkCollision(nextPos) {
            const rayOrigin = nextPos.clone();
            rayOrigin.y += 0.3; 
            const dir = nextPos.clone().sub(player.position).normalize();
            raycaster.set(rayOrigin, dir);
            const intersects = raycaster.intersectObjects(collisionObjects, true);
            if (intersects.length > 0 && intersects[0].distance < 0.6) {
                return true; 
            }
            return false;
        }

        function handleInteraction(object, config) {
            btnInteract.style.display = 'none';
            btnCrouch.style.display = 'none';
            btnExit.style.display = 'flex';

            if (config.type === "sit") {
                controlState = "sit";
                const intersectPoint = raycaster.intersectObject(object, true)[0].point;
                player.position.x = intersectPoint.x;
                player.position.z = intersectPoint.z;
                cameraYaw = (config.rotation * Math.PI) / 180;
                cameraPitch = 0; 
                targetHeight = sitHeight;

                statusHint.style.display = 'block';
                statusHint.innerText = "SPACE TO STAND UP";
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('interact-label').style.display = 'none';
            }
            else if (config.type === "tv" || config.type === "view") {
                controlState = "watch";
                if (document.pointerLockElement) document.exitPointerLock();
                
                const targetPos = new THREE.Vector3();
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                camera.lookAt(center);
                
                if (config.type === "tv") {
                    const screen = document.getElementById('screen-overlay');
                    const iframe = document.getElementById('game-frame');
                    iframe.src = config.src;
                    screen.style.display = 'block';
                    if (isMusicPlaying) bgm.pause(); 
                }
                statusHint.style.display = 'block';
                statusHint.innerText = "SPACE TO EXIT";
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('interact-label').style.display = 'none';
            }
            else if (config.type === "inspect") {
                controlState = "inspect";
                document.exitPointerLock();
                
                studioObject = object.clone();
                studioObject.scale.set(1, 1, 1);
                studioObject.rotation.set(0, 0, 0);

                if (config.inspectRotation) {
                    studioObject.rotation.x = config.inspectRotation.x || 0;
                    studioObject.rotation.y = config.inspectRotation.y || 0;
                    studioObject.rotation.z = config.inspectRotation.z || 0;
                }

                studioObject.traverse((child) => {
                    if(child.isMesh) {
                        child.material.side = THREE.DoubleSide;
                        if(child.material.isMeshStandardMaterial) {
                            child.material.metalness = 0.0; 
                            child.material.roughness = 0.5;
                            child.material.emissive = new THREE.Color(0x222222);
                        }
                    }
                });

                studioObject.updateMatrixWorld(true);

                const box = new THREE.Box3().setFromObject(studioObject);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                studioObject.position.x = -center.x;
                studioObject.position.y = -center.y;
                studioObject.position.z = -center.z;
                
                studioPivot = new THREE.Group();
                studioPivot.add(studioObject);
                sceneStudio.add(studioPivot);

                const maxDim = Math.max(size.x, size.y, size.z);
                cameraStudio.position.z = Math.max(maxDim * 2.0, 1.0); 
                cameraStudio.lookAt(0, 0, 0);

                document.getElementById('inspect-title').innerText = config.title;
                document.getElementById('inspect-desc').innerText = config.desc;
                document.getElementById('inspect-overlay').style.display = 'block';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('interact-label').style.display = 'none';
            }
        }

        function findConfigInHierarchy(mesh) {
            let current = mesh;
            while (current) {
                for (const key in INTERACT_CONFIG) {
                    if (current.name.toLowerCase().includes(key.toLowerCase())) {
                        return { config: INTERACT_CONFIG[key], root: current };
                    }
                }
                if (current.parent === scene) break; 
                current = current.parent;
            }
            return null;
        }

        function checkInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(collisionObjects, true);
            const crosshair = document.getElementById('crosshair');
            const label = document.getElementById('interact-label');

            if (intersects.length > 0) {
                const dist = intersects[0].distance;
                if (dist < 3.0) {
                    const result = findConfigInHierarchy(intersects[0].object);
                    
                    if (result) {
                        hoverConfig = result.config;
                        hoverRoot = result.root;   
                        hoverPoint = intersects[0].point;

                        crosshair.style.transform = "translate(-50%, -50%) scale(2)";
                        crosshair.style.backgroundColor = "#fff";
                        
                        label.style.display = "block";
                        let actionText = "INTERACT";
                        if(hoverConfig.type === "sit") actionText = "SIT";
                        else if(hoverConfig.type === "tv") actionText = "WATCH";
                        else if(hoverConfig.type === "inspect") actionText = "INSPECT";
                        label.innerText = actionText;

                        btnInteract.style.display = "flex";
                        btnInteract.innerText = "üëã";

                    } else {
                        hoverConfig = null;
                        resetCrosshair();
                    }
                } else {
                    hoverConfig = null;
                    resetCrosshair();
                }
            } else {
                hoverConfig = null;
                resetCrosshair();
            }
        }

        function resetCrosshair() {
            const crosshair = document.getElementById('crosshair');
            const label = document.getElementById('interact-label');
            crosshair.style.transform = "translate(-50%, -50%) scale(1)";
            crosshair.style.backgroundColor = "rgba(255,255,255,0.8)";
            label.style.display = "none";
            btnInteract.style.display = "none";
        }

        window.addEventListener('keydown', (e) => {
            keysPressed[e.code] = true;
            if (e.code === 'Space') {
                if (controlState === "move") toggleCrouch();
                else exitInteraction();
            }
        });
        window.addEventListener('keyup', (e) => keysPressed[e.code] = false);
        
        const joystickManager = nipplejs.create({
            zone: document.getElementById('joystick-zone'),
            mode: 'static', position: { left: '50%', top: '50%' }, color: 'white'
        });
        let joystickVector = { x: 0, y: 0 };
        joystickManager.on('move', (evt, data) => {
            if (data.vector) { joystickVector.x = data.vector.x; joystickVector.y = data.vector.y; }
        });
        joystickManager.on('end', () => { joystickVector.x = 0; joystickVector.y = 0; });

        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;

            const dt = clock.getDelta();

            renderer.clear();
            composer.render();

            if (controlState === "inspect" && studioPivot) {
                renderer.clearDepth(); 
                renderer.render(sceneStudio, cameraStudio);
            }

            currentCamHeight = THREE.MathUtils.lerp(currentCamHeight, targetHeight, 0.1);
            camera.position.y = currentCamHeight;

            if (controlState === "move") {
                checkInteraction();

                let moveForward = 0;
                let moveRight = 0;

                if (keysPressed['KeyW'] || keysPressed['ArrowUp']) moveForward = 1;
                if (keysPressed['KeyS'] || keysPressed['ArrowDown']) moveForward = -1;
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) moveRight = -1;
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) moveRight = 1;

                if (joystickVector.y !== 0) moveForward = joystickVector.y;
                if (joystickVector.x !== 0) moveRight = joystickVector.x;

                let speed = isCrouching ? moveSpeed * 0.5 : moveSpeed;
                if (keysPressed['ShiftLeft'] && !isCrouching) speed = sprintSpeed;

                direction.set(0, 0, 0);
                const forwardVec = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
                const rightVec = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

                if (moveForward !== 0) direction.add(forwardVec.multiplyScalar(moveForward));
                if (moveRight !== 0) direction.add(rightVec.multiplyScalar(moveRight));

                direction.normalize(); 

                if (moveForward !== 0 || moveRight !== 0) {
                    const moveDist = speed * dt;
                    const nextPos = player.position.clone().add(direction.clone().multiplyScalar(moveDist));
                    if (!checkCollision(nextPos)) {
                        player.position.copy(nextPos);
                    }
                }

                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
                camera.rotation.x = cameraPitch;
                camera.rotation.y = cameraYaw;
            } 
            else if (controlState === "sit") {
                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
                camera.rotation.y = THREE.MathUtils.lerp(camera.rotation.y, cameraYaw, 0.1);
                camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, 0, 0.1);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            cameraStudio.aspect = window.innerWidth / window.innerHeight;
            cameraStudio.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>